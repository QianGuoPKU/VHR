#! /bin/bash

printf "HostPredictor Version-1.0 
Copyright 2022 Peking University. All rights reserved.\n\n
"

################### 1. Experimental Variables ###################
export TRANSFORMERS_OFFLINE=1
export MAX_PROC=$(nproc --all) # get cores
export g=2
export b=64
export c=48 #$((MAX_PROC / 1)) # use half of max core
export m=Model/
export Tool_Path=${PWD}


# default values
#export i=/data1/jyguo/VBird/BERT/Tools/case_data/Individual_ZOVER359/
export i=/data1/jyguo/VBird/BERT/Tools/case_data/Individual_ZOVER4284/
export o=/data1/jyguo/VBird/BERT/Tools/Out/
export e=nuc_orf
export f=LM_G
export w=whole
export p=individual



################### 2. Options ###################

usage() { printf -e "Usage: $0
[-h "help"]
[-i "input_path" <string>]
[-o "output_path" <string>]  
[-m "model_path" <string>]
[-c "cores_used" <int>]
[-e "ensemble modes: choose from {nuc, nuc_orf, nuc_orf_struct}" <string>]
[-f "feature extraction modes: choose from {LM_G, LM_P, GF, PF, Phylo, Struct}" <string>]
[-p "processing input by individual file or batch: choose from {individual, batch}" <string>]
[-w "whether to run whole process or skip the feature extraction and continue from last intermediate features: choose from {whole, only_predict}" <string>]
[-g "which gpu = 0,1,2,3 or cpu = -1" <int>]" 1>&2; exit 0; }


while getopts ":i:o:m:c:e:f:p:w:g:" para; do
    case "${para}" in
        i)                           
            i=${OPTARG} 
            ;;
        o) 
            o=${OPTARG}
            ;;
        m) 
            m=${OPTARG}
            ;;
        c) 
            c=${OPTARG}
            ;;
        e) 
            e=${OPTARG}
            ;;
        f) 
            f=${OPTARG}
            ;;
        p) 
            p=${OPTARG}
            ;;
        w) 
            w=${OPTARG}
            ;;
        g) 
            g=${OPTARG}
            ;;
        *) 
            usage
            ;;
            
    esac
done
shift $((OPTIND-1))

### check for the valid input options
if [[ $e != @(None|nuc|nuc_orf|nuc_orf_struct) ]]; then
    printf " -e \"${e}\" is not an valid option! Please choose from {nuc, nuc_orf, nuc_orf_struct, None}.\n"
    exit 0; 
fi

if [[ $f != @(LM_G|LM_P|GF|PF|Phylo|Struct) ]]; then
    printf " -f \"${f}\" is not an valid option! Please choose from {LM_G, LM_P, GF, PF, Phylo, Struct}.\n"
    exit 0; 
fi

if [[ $p != @(individual|batch) ]]; then
    printf " -p \"${p}\" is not an valid option! Please choose from {individual, batch}.\n"
    exit 0; 
fi

if [[ $w != @(whole|only_predict) ]]; then
    printf " -w \"${w}\" is not an valid option! Please choose from {whole, only_predict}.\n"
    exit 0; 
fi


export i=${i}/
### create output folder
mkdir -p ${o}
export o=${o}/Host_prediction_"$(basename -- ${i%%.*})"/
mkdir -p ${o}
mkdir -p ${o}/sequence/
export LOG_PATH=${o}/logging_info.txt


### check if input valid

if [[ ! -f ${i} ]] && [[ ! -d ${i} ]]
then
    printf "${i} does not exist on your filesystem."
    exit 0; 
fi


### input types of files by mode
export genome=FALSE
export genbank=FALSE
export protein=FALSE


if [[ $e == "nuc" ]]; then
    export genome=TRUE
    
    
elif [[ $e == "nuc_orf" ]] || [[ $e == "nuc_orf_struct" ]] ; then
    export genome=TRUE
    export genbank=TRUE
    export protein=TRUE
fi

### input types of files by given
if [[ $f == "LM_G" ]] || [[ $f == "Phylo" ]]; then
    export genome=TRUE  

elif [[ $f == "LM_P" ]] || [[ $f == "PF" ]] || [[ $f == "Struct" ]]; then
    export protein=TRUE 

elif [[ $f == "GF" ]]; then
    export genome=TRUE
    export genbank=TRUE
fi

### check features needed
printf "Need genome: $genome\n"
printf "Need genbank: $genbank\n"
printf "Need protein: $protein\n\n"

if [[ $genome == 'FALSE' ]] && [[ $genbank == 'FALSE' ]] && [[ $protein == 'FALSE' ]];
then
    printf "No feature selected! need correct -f or -e parameters"
    exit 0; 
fi

################### 3. Preprocess sequences ###################
### only reprocess when in whole mode
if [[ $w == 'only_predict' ]]; then
    printf "Skip preprocessing steps! \n"
fi

if [[ $w == 'whole' ]]; then
    mkdir -p ${o}/sequence/intermediate

    if [[ $genome == "TRUE" ]]; then
        mkdir -p ${o}/sequence/genome
    fi
    if [[ $genbank == "TRUE" ]]; then
        mkdir -p ${o}/sequence/genbank 
    fi
    if [[ $protein == "TRUE" ]]; then
        mkdir -p ${o}/sequence/protein
        mkdir -p ${o}/sequence/all_protein
    fi

    ## remove old

    printf "Remove old sequences cached\n\n"
    rm -f ${o}/sequence/genome/*.f*a
    rm -f ${o}/sequence/genbank/*.gb*
    rm -f ${o}/sequence/protein/*.f*a
    rm -f ${o}/sequence/all_protein/*.f*a

    ### processing input modes ######

    if [[ $p == "individual" ]]; then
        printf "Individual Mode.\n\n"
    elif [[ $p == "batch" ]]; then
        printf "Batch Mode.\n\n"
    fi

    ### 3.1.processing genome files
    if [[ $genome == "TRUE" ]]; then
        printf "Processing genome sequences..."
        # copy files
        for dir in ${i}*/
        do

            dir=${dir%*/}      # remove the trailing "/"
            cp ${dir}/genome/*.f*a -t ${o}/sequence/intermediate/  2>/dev/null # copy to intermediate dir 
            # merge all fasta into one and rename with assembly name
            if [[ ! -z "$(ls -A ${o}/sequence/intermediate/)" ]]; then
                cat ${o}/sequence/intermediate/*.f*a > ${o}/sequence/genome/$(basename ${dir}).fna
            fi
            rm -f ${o}/sequence/intermediate/*    # remove cached files in intermediate
        done



        ###### preprocessing files #######
        cd ${o}/sequence/genome/
        for file in *.f*a; do mv -n "$file" "${file// /_}" 2>/dev/null; done    ## remove space in filename
        gawk -i inplace '!/^>/ { printf "%s", $0; n = "\n" } 
        /^>/ { print n $0; n = "" }
        END { printf "%s", n }
        ' *.f*a                 ## remove newline char
        sed -i '/^$/d' *.f*a ## remove empty lines
        gawk -i inplace 'BEGIN{FS=" "}{if(!/>/){print toupper($0)}else{print $1}}' *.f*a    ## uppercase
        sed -i '/^>/!s/[RHNYWBMSVKD]/N/g' *.f*a   ## avoid out-of-vocabulary
        cd ${Tool_Path}  ## change working dir
    fi

    ### 3.2.processing protein files
    if [[ $protein == "TRUE" ]]; then
        printf "Processing protein sequences..."
        # copy files
        for dir in ${i}*/
        do

            dir=${dir%*/}      # remove the trailing "/"
            cp ${dir}/protein/*.f*a -t ${o}/sequence/intermediate/  2>/dev/null ## copy to intermediate dir 
            # merge all fasta into one and rename with assembly name
            if [[ ! -z "$(ls -A ${o}/sequence/intermediate/)" ]]; then
                cat ${o}/sequence/intermediate/*.f*a > ${o}/sequence/protein/$(basename ${dir}).faa
            fi
            
            rm -f ${o}/sequence/intermediate/*    ## remove cached files in intermediate
        done

        ###### preprocessing files #######

        cd ${o}/sequence/protein/
        for file in *.f*a; do mv -n "$file" "${file// /_}"  2>/dev/null; done    ## remove space in filename
        #sed -i '/>/s/\ /_/g' *.f*a    ## process header split with '_'
        gawk -i inplace '!/^>/ { printf "%s", $0; n = "\n" } 
        /^>/ { print n $0; n = "" }
        END { printf "%s", n }
        ' *.f*a  ## remove newline char
        sed -i '/^$/d' *.f*a ## remove empty lines
        gawk -i inplace 'BEGIN{FS=" "}{if(!/>/){print toupper($0)}else{print $1}}' *.f*a ## uppercase
        sed -i '/^>/!s/J/X/g' *.f*a  ## avoid out-of-vocabulary
        cd ${Tool_Path}
    fi

    ### 3.3.processing protein files separately
    if [[ $protein == "TRUE" ]]; then
        printf "Processing protein sequences separately..."
        # copy files
        for dir in ${i}*/
        do
            dir=${dir%*/}      # remove the trailing "/"
            cp ${dir}/protein/*.f*a -t ${o}/sequence/all_protein/  2>/dev/null ## copy separately
        done

        ###### preprocessing files #######
        cd ${o}/sequence/all_protein/
        for file in *.f*a; do mv -n "$file" "${file// /_}"  2>/dev/null; done    ## remove space in filename
        gawk -i inplace '!/^>/ { printf "%s", $0; n = "\n" } 
        /^>/ { print n $0; n = "" }
        END { printf "%s", n }
        ' *.f*a  ## remove newline char
        sed -i '/^>/d' *.f*a ## remove headers
        sed -i '/^$/d' *.f*a ## remove empty lines
        gawk -i inplace 'BEGIN{FS=" "}{if(!/>/){print toupper($0)}else{print $1}}' *.f*a ## uppercase
        sed -i '/^>/!s/J/X/g' *.f*a  ## avoid out-of-vocabulary
        cd ${Tool_Path}
    fi

    ### 3.4.processing genbank files
    if [[ $genbank == "TRUE" ]]; then
        printf "Processing genbank files...\n\n"
        # copy files
        for dir in ${i}*/
        do
            dir=${dir%*/}      # remove the trailing "/"
            cp ${dir}/genbank/*.gb* ${o}/sequence/genbank/  2>/dev/null
        done

    fi
fi


################### 4. Extract Features ###################
### feature extraction mode
export LM_G=FALSE
export Phylo=FALSE
export GF=FALSE
export LM_P=FALSE
export PF=FALSE
export Struct=FALSE

######## default parameters for feature extraction
export Genome_MAX_LEN=512
export Genome_SIZE=3000
export Genome_OVERLAP=1500

export Protein_MAX_LEN=510
export Protein_SIZE=510
export Protein_OVERLAP=205

##########################################################

if [[ $e == "nuc" ]]; then
    export LM_G=TRUE
    export Phylo=TRUE
    
elif [[ $e == "nuc_orf" ]]; then
    export LM_G=TRUE
    export Phylo=TRUE
    export GF=TRUE
    export LM_P=TRUE
    export PF=TRUE
    
elif [[ $e == "nuc_orf_struct" ]]; then
    export LM_G=TRUE
    export Phylo=TRUE
    export GF=TRUE
    export LM_P=TRUE
    export PF=TRUE
    export Struct=TRUE
fi

### input types of files by given
if   [[ $f == "LM_G" ]]; then
    export LM_G=TRUE
elif [[ $f == "LM_P" ]]; then
    export LM_P=TRUE
elif [[ $f == "GF" ]]; then
    export GF=TRUE
elif [[ $f == "PF" ]]; then
    export PF=TRUE
elif [[ $f == "Phylo" ]]; then
    export Phylo=TRUE
elif [[ $f == "Struct" ]]; then
    export Struct=TRUE
fi

printf "Feature extraction methods: \n"
printf "By LM_G: $LM_G \n"
printf "By LM_P: $LM_P \n"
printf "By Phylo: $Phylo \n"
printf "By GF: $GF \n"
printf "By PF: $PF \n"
printf "By Struct: $Struct \n\n"

if [[ $LM_G == 'FALSE' ]] && [[ $LM_P == 'FALSE' ]] && [[ $Phylo == 'FALSE' ]] && [[ $PF == 'FALSE' ]] && [[ $GF == 'FALSE' ]] && [[ $Struct == 'FALSE' ]];
then
    printf "No feature selected! need correct -f or -e parameters"
    exit 0; 
fi

###### process features
if [[ $w == 'only_predict' ]]; then
    printf "Skip feature extraction steps! \n"
fi

##### processing all features
if [[ $w == 'whole' ]]; then

    mkdir -p ${o}/features/
    for FEAT in LM_G LM_P Phylo PF GF Struct
    do
        mkdir -p ${o}/features/${FEAT}
        rm -f ${o}/features/${FEAT}/* #remove old results
    done

    #### P1.Language Model Genome
    if   [[ ${LM_G} == "TRUE" ]] ; then
        export FEAT=LM_G

        cp ${o}/sequence/genome/*.f*a  ${o}/features/${FEAT}/
        cd ${o}/features/${FEAT}/
        sed -i '/>/d' *.f*a     ## remove header
        gawk -i inplace '!/^>/ { printf "%s", $0; n = "\n" } 
        /^>/ { print n $0; n = "" }
        END { printf "%s", n }
        ' *.f*a  ## remove newline char
        for file in *.f*a; do sed -i "s/^/>${file%.fna}\n/g" "${file}"; done  ## add header
        for temp_f in *.f*a; do (cat "$temp_f" ; echo) >> all_sequences.fna  && rm "$temp_f" || break ; done ## merge into one

        cd ${Tool_Path}

        ### process features for Language model
        python Process/data_process.py \
            --mode Genome \
            --filepath ${o}/features/${FEAT}/all_sequences.fna \
            --out_folder ${o}/features/${FEAT}/ \
            --size $Genome_SIZE \
            --overlap $Genome_OVERLAP \

        printf "Finish processing ${FEAT} features"
    fi

    #### P2.Phylogenetic
    if   [[ ${Phylo} == "TRUE" ]] ; then
        export FEAT=Phylo

        cp ${o}/sequence/genome/*.f*a -t ${o}/features/${FEAT}/
        cd ${o}/features/${FEAT}/
        sed -i '/>/d' *.f*a     ## remove header
        gawk -i inplace '!/^>/ { printf "%s", $0; n = "\n" } 
        /^>/ { print n $0; n = "" }
        END { printf "%s", n }
        ' *.f*a  ## remove newline char
        for file in *.f*a; do sed -i "s/^/>${file%.fna}\n/g" "${file}"; done  ## add header
        for temp_f in *.f*a; do (cat "$temp_f" ; echo) >> all_sequences.fna  && rm "$temp_f" || break ; done ## merge into one
        cd ${Tool_Path}

        ### run blast
        Query=${o}/features/${FEAT}/all_sequences.fna
        DB=BLAST/viv_all.db
        Out=${o}/features/${FEAT}/blast_out.txt
        ### run
        blastn -task blastn -db $DB -query $Query -out $Out -outfmt 6  -num_threads $c  -max_hsps 1  -reward 2  -word_size 8  -gapopen 2 -gapextend 2 -evalue 0.001 -perc_identity 30 -qcov_hsp_perc 60

        printf "Finish processing ${FEAT} features \n"
    fi

    #### P3.Genome features
    if   [[ ${GF} == "TRUE" ]] ; then
        export FEAT=GF  
        printf "Finish processing ${FEAT} features \n"

        python Process/Genome_feature.py \
            --assembly_path ${o}/sequence/genome/ \
            --filepath ${o}/sequence/genbank/ \
            --ref_cols ${PWD}/Process/ref_cols.pickle \
            --out_folder ${o}/features/${FEAT}/ \
            --CPB_path ${PWD}/CPB/CPB_Machine.jar \

    fi


    #### P4.Language Model Protein
    if   [[ ${LM_P} == "TRUE" ]] ; then
        export FEAT=LM_P

        ### process features for Language model
        python Process/data_process.py \
            --mode Protein \
            --filepath ${o}/sequence/protein/ \
            --out_folder ${o}/features/${FEAT}/ \
            --size $Protein_SIZE \
            --overlap $Protein_OVERLAP \

        printf "Finish processing ${FEAT} features \n"

    fi

    #### P5.Protein features
    if   [[ ${PF} == "TRUE" ]] ; then
        export FEAT=PF

        python Process/Protein_feature.py \
            --assembly_path ${o}/sequence/protein/ \
            --filepath ${o}/sequence/all_protein/ \
            --out_folder ${o}/features/${FEAT}/ \
            --process $c \

        printf "Finish processing ${FEAT} features \n"
    fi

    #### P6.Protein structures
    if   [[ ${Struct} == "TRUE" ]] ; then
        export FEAT=Struct

        cp ${o}/sequence/protein/*.f*a -t ${o}/features/${FEAT}/
        cd ${o}/features/${FEAT}/

        for temp_f in *.f*a; do (cat "$temp_f" ; echo) >> all_sequences.fna  && rm "$temp_f" || break ; done ## merge into one
        sed -i '/^$/d' all_sequences.fna ## remove empty lines
        cd ${Tool_Path}

        ### run blast
        Query=${o}/features/${FEAT}/all_sequences.fna
        DB=BLAST/hvidb_struct.db
        Out=${o}/features/${FEAT}/blast_out.txt

        blastp -task blastp -db $DB -query $Query -out $Out -outfmt 6  -num_threads $c  -word_size 6  -evalue 0.001 -qcov_hsp_perc 60

        printf "Finish processing ${FEAT} features \n"
    fi
fi 

################### 5. Run predictions ###################
export TASK=VIV_mhc_pos
export LM_G_Tokenizer=Tokenizer/LM_G/viro_bpe_32000.json
export LM_P_Tokenizer=Tokenizer/LM_P/ProtTrans
export Cols=Cates/categories.cols
export Human_Cols=Cates/human_categories.cols
export hierarchy=Cates/taxa_struct.json
export G_size=768
export G2L=384
export Support_NUM=5
export VIV_label_num=79
export human_label_num=6
export VIV_REF=Predict/VIV_80_sep.csv
export Cut_off=Predict/cut_off.pickle
export Struct_evi=Predict/struct_evidence.csv
export Struct_evi_cols=Predict/struct_evidence_cols.csv



mkdir -p ${o}/prediction/
for FEAT in LM_G LM_P Phylo PF GF Struct
do
    mkdir -p ${o}/prediction/${FEAT}
    rm -f ${o}/prediction/${FEAT}/* #remove old results
done


#### Pre1.Language Model Genome
if   [[ ${LM_G} == "TRUE" ]] ; then
    export FEAT=LM_G
    CUDA_VISIBLE_DEVICES=$g python Predict/run_finetune_vbird.py \
        --output_dir ${o}/prediction/${FEAT} \
        --model_type_limit BertMHC \
        --model_name_or_path $m/${FEAT}/ \
        --max_length $Genome_MAX_LEN \
        --do_predict_no_label \
        --validation_file ${o}/features/${FEAT}/processed_input.csv \
        --task_name $TASK \
        --customize_tokenizer \
        --tokenizer_name $LM_G_Tokenizer \
        --per_device_eval_batch_size $b \
        --preprocessing_num_workers $c \
        --logger_path Logger/${FEAT}.txt \
        --hierarchy_structure $hierarchy \
        --CLS_dropout 0.5 \
        --fp16 True \
        
    python Predict/extract_prediction.py \
        --predict_folder ${o}/prediction/${FEAT}/ \
        --feature_folder ${o}/features/${FEAT}/ \
        --feature ${FEAT} \
        --hierarchy_structure $hierarchy \
        --categories ${Cols} \
        --cutoff ${Cut_off} \
        --agg_method topk \
        
fi
#### Pre2.Phylogenetic
if   [[ ${Phylo} == "TRUE" ]] ; then
    export FEAT=Phylo
    python Predict/PN_cal.py \
        --filepath ${o}/features/${FEAT}/ \
        --out_folder ${o}/prediction/${FEAT}/ \
        --reference_path ${VIV_REF} \
        --query_path ${o}/features/${FEAT}/all_sequences.fna \
        --support_num $Support_NUM \
        --process $c \
    
    python Predict/extract_prediction.py \
        --predict_folder ${o}/prediction/${FEAT}/ \
        --feature_folder ${o}/features/${FEAT}/ \
        --feature ${FEAT} \
        --hierarchy_structure $hierarchy \
        --categories ${Cols} \
        --cutoff ${Cut_off} \
        --agg_method topk \
   
fi

#### Pre3.Genome features
if   [[ ${GF} == "TRUE" ]] ; then
    export FEAT=GF
    CUDA_VISIBLE_DEVICES=$g python Predict/run_train_features.py \
        --output_dir ${o}/prediction/${FEAT} \
        --feature_type VIV_gf \
        --label_num $VIV_label_num \
        --model_name_or_path $m/${FEAT}/ \
        --validation_file ${o}/features/${FEAT}/processed_input.csv \
        --do_predict_no_label \
        --hierarchy_structure $hierarchy \
        --g_size $G_size \
        --G2L $G2L \
        --per_device_eval_batch_size $b \
        --preprocessing_num_workers $c \
        --dropout_prob 0.1 \
        --fp16 True \
        
    python Predict/extract_prediction.py \
        --predict_folder ${o}/prediction/${FEAT}/ \
        --feature_folder ${o}/features/${FEAT}/ \
        --feature ${FEAT} \
        --hierarchy_structure $hierarchy \
        --categories ${Cols} \
        --cutoff ${Cut_off} \
        --agg_method topk \
        
fi
    
#### Pre4.Language Model Protein
if   [[ ${LM_P} == "TRUE" ]] ; then
    export FEAT=LM_P
    CUDA_VISIBLE_DEVICES=$g python Predict/run_finetune_vbird.py \
        --output_dir ${o}/prediction/${FEAT} \
        --model_type_limit BertMHC \
        --model_name_or_path $m/${FEAT}/ \
        --max_length $Protein_MAX_LEN \
        --do_predict_no_label \
        --validation_file ${o}/features/${FEAT}/processed_input.csv \
        --task_name $TASK \
        --tokenizer_name $LM_P_Tokenizer \
        --per_device_eval_batch_size $b \
        --preprocessing_num_workers $c \
        --logger_path Logger/${FEAT}.txt \
        --hierarchy_structure $hierarchy \
        --CLS_dropout 0 \
        --fp16 True \
        
    python Predict/extract_prediction.py \
        --predict_folder ${o}/prediction/${FEAT}/ \
        --feature_folder ${o}/features/${FEAT}/ \
        --feature ${FEAT} \
        --hierarchy_structure $hierarchy \
        --categories ${Cols} \
        --cutoff ${Cut_off} \
        --agg_method topk \
        
fi

### Pre5.Protein features
if   [[ ${PF} == "TRUE" ]] ; then
    export FEAT=PF
    CUDA_VISIBLE_DEVICES=$g python Predict/run_train_features.py \
        --output_dir ${o}/prediction/${FEAT}/ \
        --feature_type VIV_pf \
        --label_num $VIV_label_num \
        --model_name_or_path $m/${FEAT}/ \
        --validation_file ${o}/features/${FEAT}/processed_input.csv \
        --do_predict_no_label \
        --hierarchy_structure $hierarchy \
        --g_size $G_size \
        --G2L $G2L \
        --per_device_eval_batch_size $b \
        --preprocessing_num_workers $c \
        --dropout_prob 0.1 \
        --fp16 True \
        
    python Predict/extract_prediction.py \
        --predict_folder ${o}/prediction/${FEAT}/ \
        --feature_folder ${o}/features/${FEAT}/ \
        --feature ${FEAT} \
        --hierarchy_structure $hierarchy \
        --categories ${Cols} \
        --cutoff ${Cut_off} \
        --agg_method topk \
        
fi

# #### Pre6.Protein structures
if   [[ ${Struct} == "TRUE" ]] ; then
    export FEAT=Struct
    python Predict/extract_structure.py \
        --assembly_path ${o}/sequence/protein/ \
        --predict_folder ${o}/prediction/${FEAT}/ \
        --feature_folder ${o}/features/${FEAT}/ \
        --model_name_or_path $m/${FEAT}/ \
        --struct_evidence $Struct_evi \
        --struct_evidence_col $Struct_evi_cols \
        --feature ${FEAT} \
        --categories ${Human_Cols} \
        
fi


# ################### 6. Ensemble predictions ###################
### check
if [[ $e != @(nuc|nuc_orf|nuc_orf_struct) ]]; then
    printf "Finish prediction without using stacking models. \n"
    exit 0;
    
fi 


mkdir -p ${o}/ensemble
for base in six_base five_base two_base final
do
    mkdir -p ${o}/ensemble/$base/
    rm -f ${o}/ensemble/$base/* #remove old results
done



python Predict/aggregate_for_stacking.py \
    --predict_folder ${o}/prediction/ \
    --save_folder ${o}/ensemble/ \
    --ensemble_mode $e \
    
printf "Finish aggregating base model probs. \n"
       

### predict


for base in six_base five_base two_base
do
    export Save_path=${o}/ensemble/$base/
    export base_path=${o}/ensemble/$base/
    ########## 改动适应新的ensemble
    export model_path=${Tool_Path}/$m/ensemble/$base/LR_model.pkl
    export Hie_path=${Tool_Path}/Cates/ensemble/$base/taxa_struct.json
    export HOST_TYPE=Whole
    
    if [[ $base != @(five_base|two_base) ]]; then
        export HOST_TYPE=Human
    fi
    
    
    if [[ -f ${o}/ensemble/$base/test_prob_agg.pkl ]]; then
        CUDA_VISIBLE_DEVICES=$g python Predict/Stacking_LR.py \
            --trained_model $model_path \
            --base_path $base_path \
            --save_path $Save_path \
            --hierarchy_structure $Hie_path \
            --base_model_list MODEL_list.pkl \
            --valid_prob test_prob_agg.pkl \
            --LABELS LABELS.pkl \
            --base_model_list MODEL_list.pkl \
            
    fi
done



printf "Finish prediction of stacking models. \n"

export ensemble_path=${o}/ensemble/
export output_path=${o}/ensemble/final/
export all_cates=${Tool_Path}/Cates/categories.cols
export Hie_path=${Tool_Path}/Cates/ensemble/five_base/taxa_struct.json

python Predict/ensemble_extract_prediction.py \
    --ensemble_path $ensemble_path \
    --output_path $output_path \
    --all_cates $all_cates \
    --hierarchy_structure $Hie_path \
    --cutoff ${Cut_off} \
        
printf "Out put final results in ${output_path}. \n"